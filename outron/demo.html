<!DOCTYPE html>
<html>
  <head>
    <title>OUTRON - DEMO</title>
    <script src="./src/matrix.js"></script>
    <script src="./src/timeline.js"></script>
    <script src="./src/events3.js"></script>
    <script src="./src/palette.js"></script>
    <script src="./src/text.js"></script>
    <script src="./src/webgl.js"></script>
    <script src="./src/geometry.js"></script>
    <script src="./src/canvas.js"></script>
    <script src="./src/effects.js"></script>
    <script src="./src/effect-tunnel.js"></script>
    <script src="./src/effect-meta-balls.js"></script>
    <script src="./src/effect-meta-cubes.js"></script>
    <script src="./src/effect-rosebud.js"></script>
    <script src="./src/effect-fractal-1.js"></script>
    <script src="./src/effect-fractal-2.js"></script>
    <script src="./src/effect-fractal-3.js"></script>
    <script src="./src/effect-cyborg.js"></script>
    <script src="./src/demo.js"></script>

    <!-- TUNNEL EFFECT SHADERS -->

    <script id="tunnel-vertex-shader" type="x-shader/x-vertex">

      attribute vec4 aVertexPosition;
      attribute vec2 aTextureCoord;

      varying highp vec2 vTextureCoord;

      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform float uStretch;

      void main() {
        vec4 position = vec4(aVertexPosition.xyz,1.0);
        position.x += normalize(position.x) * uStretch;
        gl_Position = uProjectionMatrix * uModelViewMatrix * position;
        vTextureCoord = aTextureCoord;
      }
    </script>

    <script id="tunnel-fragment-shader" type="x-shader/x-fragment">
      precision mediump float;

      varying highp vec2 vTextureCoord;
      uniform sampler2D uSampler;
      uniform float uFlicker;

      void main() {
        gl_FragColor = texture2D(uSampler, vTextureCoord) + uFlicker;
      }
    </script>

    <!-- META BALLS SHADERS -->

    <script id="flat-vertex-shader" type="x-shader/x-vertex">

      attribute vec4 aVertexPosition;

      void main() {
        gl_Position = aVertexPosition;
      }
    </script>

    <script id="metaball-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        uniform float uWidth, uHeight, uTime, uKickCounter, uHitCounter, uFlicker, uX;
        uniform vec3 uLightPosition, uRayOrigin;
        uniform vec4 uColor;
        uniform float uNoise[24];

        float smin( float a, float b, float k ) {
          float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );
          return mix( b, a, h ) - k*h*(1.0-h);
        }

        float getMetaBallsRayMarchGetDistance(vec3 point) {
          float d = 50.;

          for (int i=0; i < 12; i++) {
              vec4 ball = vec4(0.,1., 5., .6 + uNoise[i+12] + uHitCounter + uKickCounter);
              float fi = float(i); // because % is not supported

              if (mod(fi,2.) == 0.) {
                ball.x += uNoise[i]*2. + sin(uNoise[i] + uTime*.5);
                ball.y += uNoise[i]*2. + cos(uNoise[i] + uTime*.3);
                ball.z += uNoise[i] + sin(uNoise[i] + uTime*.7);
              }
              if (mod(fi,3.) == 1.) {
                  ball.x += uNoise[i+12] + sin(uNoise[i] + uTime);
                  ball.y += uNoise[i] + cos(uNoise[i] + uTime);
                  ball.z += uNoise[i] + cos(uNoise[i] + uTime)*3.;
              }
              if (mod(fi,4.) == 2.) {
                  ball.x += uNoise[i] - cos(uNoise[i+12] + uTime*2.) *3.;
                  ball.yz += uNoise[i+12] + sin(uNoise[i+12] + uTime*2.) *3.;
              }
              if (mod(fi,5.) == 3.) {
                  ball.xyz += uNoise[i] + sin(uNoise[i+12] + uTime*3.) *2.;
              }
              if (mod(fi,6.) == 4.) {
                  ball.x += uNoise[i] + cos(uNoise[i+12] + uTime*4.) *2.;
                  ball.yz += uNoise[i] - cos(uNoise[i+12] + uTime*4.) *2.;
              }

              float bf = length(point-ball.xyz)-ball.w;
              d = smin(bf, d, .6);

          }

          return d;
      }

      vec3 getMetaBallsRayMarchGetNormal(vec3 point) {
        float distance = getMetaBallsRayMarchGetDistance(point);
        vec2 e = vec2(.01,0);
        return normalize(distance - vec3(
            getMetaBallsRayMarchGetDistance(point-e.xyy),
            getMetaBallsRayMarchGetDistance(point-e.yxy),
            getMetaBallsRayMarchGetDistance(point-e.yyx)));
      }

      vec2 getMetaBallsRayMarch(vec3 rayOrgin, vec3 rayDirection) {
        float distance=0.;
        for(int i=0; i<100; i++) {
          vec3 point = rayOrgin + rayDirection * distance;
          float surfaceDistance = getMetaBallsRayMarchGetDistance(point);
          distance += surfaceDistance;
          if (distance>27. || surfaceDistance<.01) break;
        }
        return vec2(distance,0);
      }

      float getMetaBallsGetLight(vec3 point, vec3 normal) {
        vec3 direction = normalize(uLightPosition-point);
        float dif = clamp(dot(normal, direction), 0., 1.);
        vec2 d = getMetaBallsRayMarch(point+normal*.1, direction);
        if ( d.x < length(uLightPosition-point)) {
            dif *= 0.5;
        } else {
            dif -= d.y*.006;
        }
        return dif;
      }

      vec4 getMetaBalls(vec2 uv) {

          vec4 col = vec4(0.);
          //vec3 rayOrgin = vec3(0., 1., -1.);
          //rayOrgin.xz *= rotate(uTime);

          vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));
          vec2 d = getMetaBallsRayMarch(uRayOrigin, rayDirection);

          if (d.x < 17.) {
              vec3 p = uRayOrigin + rayDirection * d.x;
              vec3 n = getMetaBallsRayMarchGetNormal(p);
              float light = getMetaBallsGetLight(p, n) + .1;
              col = vec4(light*uColor.r,uColor.g*light,uColor.b*light, 1.);
              col.rgb += uColor.rgb * (1.0+n.z) * (0.2 + uFlicker);
              col.rgb += uKickCounter;
              col *= col + col + col;
          }

          return col;
      }

      void main() {
        vec2 r = vec2(uWidth,uHeight);
        vec2 uv = (gl_FragCoord.xy-.5*r.xy)/r.y;
        gl_FragColor = getMetaBalls(uv);
      }
    </script>

    <!-- META CUBES SHADERS -->

    <script id="metacubes-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        uniform float uWidth, uHeight, uTime, uKickCounter, uHitCounter, uFlicker, uX;
        uniform vec3 uLightPosition, uRayOrigin;
        uniform vec4 uColor;
        uniform float uNoise[24];

        float smin( float a, float b, float k ) {
          float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );
          return mix( b, a, h ) - k*h*(1.0-h);
        }

        mat2 Rotate(float a) {
          float s = sin(a);
          float c = cos(a);
          return mat2(c, -s, s, c);
        }

        float getMetaCubesRayMarchGetDistance(vec3 point) {
          float d = 50.;

          for (int i=0; i < 9; i++) {
              vec4 ball = vec4(0.,1., 5., .6 + uNoise[i+12]*.5 + uHitCounter + uKickCounter);
              float fi = float(i); // because % is not supported

              if (mod(fi,2.) == 0.) {
                ball.x += uNoise[i]*1.7 + sin(uNoise[i] + uTime*.6);
                ball.y += uNoise[i+5]*2.2 + cos(uNoise[i] + uTime*.4);
                ball.z += uNoise[i+2]*.9 + sin(uNoise[i+4] + uTime*.8);
              } else {
                ball.x += uNoise[i+12] + sin(uNoise[i] + uTime);
                ball.y += uNoise[i] + cos(uNoise[i] + uTime);
                ball.z += uNoise[i] + cos(uNoise[i] + uTime)*3.5;
              }
              if (mod(fi,3.) == 2.) {
                  ball.x += uNoise[i] - cos(uNoise[i+12] + uTime*2.) *3.2;
                  ball.yz += uNoise[i+12] + sin(uNoise[i+12] + uTime*2.) *3.2;
              }
              if (mod(fi,4.) == 3.) {
                  ball.xyz += uNoise[i] + sin(uNoise[i+12] + uTime*3.) *2.;
              }
              if (mod(fi,5.) == 4.) {
                  ball.x += uNoise[i] + cos(uNoise[i+12] + uTime*4.) *2.;
                  ball.yz += uNoise[i] - cos(uNoise[i+12] + uTime*4.) *2.;
              }

              //float bf = length(point-ball.xyz)-ball.w;
              vec3 spoint = point-ball.xyz;
              spoint.xy *= Rotate(ball.x + uNoise[i]);
              spoint.xz *= Rotate(ball.y);
              spoint.yz *= Rotate(ball.z);
              float bf = length(max(abs(spoint)-vec3(ball.w), 0.));


              d = smin(bf, d, .4);

          }

          return d;
      }

      vec3 getMetaCubesRayMarchGetNormal(vec3 point) {
        float distance = getMetaCubesRayMarchGetDistance(point);
        vec2 e = vec2(.01,0);
        return normalize(distance - vec3(
            getMetaCubesRayMarchGetDistance(point-e.xyy),
            getMetaCubesRayMarchGetDistance(point-e.yxy),
            getMetaCubesRayMarchGetDistance(point-e.yyx)));
      }

      vec2 getMetaCubesRayMarch(vec3 rayOrgin, vec3 rayDirection) {
        float distance=0.;
        for(int i=0; i<10; i++) {
          vec3 point = rayOrgin + rayDirection * distance;
          float surfaceDistance = getMetaCubesRayMarchGetDistance(point);
          distance += surfaceDistance;
          //if (distance>27. || surfaceDistance<.002) break;
        }
        return vec2(distance,0);
      }

      float getMetaCubesGetLight(vec3 point, vec3 normal) {
        vec3 direction = normalize(uLightPosition-point);
        float dif = clamp(dot(normal, direction), 0., 1.);
        vec2 d = getMetaCubesRayMarch(point+normal*.1, direction);
        if ( d.x < length(uLightPosition-point)) {
            dif *= 0.5;
        } else {
            dif -= d.y*.006;
        }
        return dif;
      }

      vec4 getMetaCubes(vec2 uv) {

          vec4 col = vec4(0.);
          //vec3 rayOrgin = vec3(0., 1., -1.);
          //rayOrgin.xz *= rotate(uTime);

          vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));
          vec2 d = getMetaCubesRayMarch(uRayOrigin, rayDirection);

          if (d.x < 17.) {
              vec3 p = uRayOrigin + rayDirection * d.x;
              vec3 n = getMetaCubesRayMarchGetNormal(p);
              float light = getMetaCubesGetLight(p, n) + .1;
              col = vec4(light*uColor.r,uColor.g*light,uColor.b*light, 1.0);
              col.rgb += uColor.rgb * (1.0+n.z) * (0.2 + uFlicker);
              col.rgb += uKickCounter;
              col *= col *3.0;
              col.rgb += 0.01;
          }

          return col;
      }

      void main() {
        vec2 r = vec2(uWidth,uHeight);
        vec2 uv = (gl_FragCoord.xy-.5*r.xy)/r.y;
        gl_FragColor = getMetaCubes(uv);
      }
    </script>

    <!-- ROSEBUD-->

    <script id="rosebud-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        uniform float uWidth ,uHeight, uTime, uKickCounter, uFlicker;
        uniform vec4 uColor;

        vec4 doBallEffect(vec2 uv, float time) {

          float kickAdd = (uKickCounter > 0. ? uKickCounter * .1 : 0.);

          float val = max(pow(sqrt(dot(uv,uv)-.05-kickAdd),.5), 0.2 );
          uv /= val;

          vec3 rayOrgin = vec3(0, 3.+sin(time)*2., mod(time,4.));
          vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));

          float d = 0.;
          vec4 sphere = vec4(2, 2, 1, 1);

          for(int i=0; i<11; i++) {
            vec3 point = rayOrgin + rayDirection * d;
            vec3 spoint = mod(point, 4.);

            float sphereDist = length(spoint-sphere.xyz)-sphere.w;
            float planeDist = point.y;

            float surfaceDistance = min(sphereDist, planeDist);
            d += surfaceDistance;
            if (d > 40. || surfaceDistance<.1) break;
          }

          // color
          vec3 col = vec3(1.-(d/20.));
          col *= uColor.rgb * 1.3;
          col *= col;
          col += 0.05;
          return vec4(col.r,col.g,col.b ,1.0) / (1.0 + val * 0.5);

      }

        void main() {

          vec2 r = vec2(uWidth,uHeight);
          vec2 uv = (gl_FragCoord.xy-.5*r.xy)/r.y;
          gl_FragColor = doBallEffect( uv, uTime*5.+(uKickCounter > 0. ? uKickCounter * .1 : 0.)) + uFlicker;
        }
    </script>

    <!-- FRACTAL 1 -->

    <script id="fractal-1-fragment-shader" type="x-shader/x-fragment">
      precision mediump float;

      uniform float uWidth, uHeight, uTime, uKickCounter, uFlicker;
      uniform mat2 uRotate1, uRotate2;
      uniform vec4 uColor;

      // shader effects start helper functions
      mat2 rotate(float a) {
        float s = sin(a);
        float c = cos(a);
        return mat2(c, -s, s, c);
      }

      // does fly in the factal and rotates the camera
      vec4 doFractalEffect(vec4 fragCoord, vec2 iResolution) {
        vec4 o;
        float e,g,v, s = 2.,t = uTime+sin(uTime);


         for(float i=0.;i<35.;i++){
            v=2.;
            vec3 p = vec3((fragCoord.xy*v-iResolution.xy)/iResolution.y*g,g);
            p.yz *= rotate(.1 + uTime*0.1);
            //p.yz *= uRotate1;
            p.y -= .45 + sin(t)*.01;
            //p.xy *= rotate(.1);
            p.xy *= uRotate2;
            for(int j=0; j<7 ; j++)
                p.xz = length(p.xz) * vec2(cos(e=fract(atan(p.x,p.z)*.7+(j<2?t/3.:s))-.5),e),
                v/=e=clamp(dot(p,p),.1,.52),
                p=abs(p)/e-vec3(.3,3,0);
            g+=e=(p.x)/v;
            o+=.02/exp(e*3e4);
        }

        //vec4 col = vec4(vec3(o.x*uColor.r+e*196., o.y*uColor.g+e*0.01, o.z*uColor.b+e*0.001),1.0) * 1.2 + 0.1;
        //vec4 col = vec4(vec3(o.x*uColor.r+e*196., o.y*uColor.g+e*0.01, o.z*uColor.b+e*0.001),1.0) * 1.2 + 0.1;
        vec4 col = vec4(vec3(o.x*uColor.r*0.9+e*196.*uKickCounter, o.y*uColor.g, o.z*uColor.b),1.0) * 1.2 + 0.4;

        //return vec4(vec3(o.x*0.5+e*196., o.y*0.5+e*0.01, o.z*0.8+e*0.001),1.0) * 1.2 + 0.1;
        return col * col * col + uFlicker;
        //return vec4(vec3(o.x+e*522., o.y+g, o.z+ g*3.),1.0);
      }

      void main() {

        vec2 r = vec2(uWidth,uHeight);
        gl_FragColor = doFractalEffect( gl_FragCoord, r);
      }
    </script>

    <!-- FRACTAL 2-->

    <script id="fractal-2-fragment-shader" type="x-shader/x-fragment">
      precision mediump float;

      uniform float uWidth, uHeight, uTime, uKickCounter, uFlicker;
      uniform vec4 uColor;

      mat2 rotate(float a) {
        float s = sin(a);
        float c = cos(a);
        return mat2(c, -s, s, c);
      }

      vec4 doBallFractal(vec4 fragCoord, vec2 r, float time) {
        vec3 point,color;
        float e,g,S,u;
        for(float i=0.;i<9.;i++){

            float zoom = 0.05 + sin(time) * 0.9;
            point=vec3((fragCoord.xy-.5*r.xy)/r.y*g,g-zoom);
            point.xz*=rotate(time*.2);
            point.xy*=rotate(time*.5);
            point--;
            S=6.;

            for(int j=0;j<10;j++) {
                u = dot(point,point)*(.7-(1.0/5.0));
                S /= u;
                point /= u;
                point = abs(point+.99999)-.999999;
            }
            e = abs(point.y)/S;
            g += e;
          }

          color += normalize(++point).y;

          //color += point*.05;
          //color.r += e;
          //color.b += e;
          /*
          color.r *= 2.0;
          color.g *= 0.7;
          color.b *= 0.6;// + 0.5;
          color.b += 0.1;*/
          color *= uColor.rgb;

        return vec4(color, 1.);
      }

      void main() {
        vec2 r = vec2(uWidth, uHeight);
        vec2 uv = (gl_FragCoord.xy-.5*r.xy)/r.y;

        gl_FragColor = doBallFractal(gl_FragCoord, r, uTime) + uFlicker + uKickCounter;
      }
    </script>

    <!-- FRACTAL 3-->

    <script id="fractal-3-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        uniform float uWidth, uHeight, uTime, uKickCounter, uFlicker;
        uniform vec4 uColor;

        mat2 rotate(float a) {
          float s = sin(a);
          float c = cos(a);
          return mat2(c, -s, s, c);
        }

        float getFractalValue(vec2 uv, float angle) {
          for (float i=0.; i < 14.; i+= 1.) {
              uv = abs(uv);
              uv -= .5 ;
              uv *= (1.1 + sin(uTime*0.1)*0.4 + uKickCounter * 0.3);
              uv *= mat2(
                  cos(angle), -sin(angle), sin(angle), cos(angle)
              );
          }
          return length(uv);
      }

      float GetDistance(vec3 point, float time) {
          vec3 movingPoint = point;
          movingPoint.z += time*2.;
        float gyr = dot(sin(movingPoint*.7), cos(movingPoint.zxy));
          movingPoint.z += time*.5;
          float gyr2 = dot(sin(movingPoint*.5), cos(movingPoint.zxy*.9));
          float text = getFractalValue((point.xy)*.5, 1.1 + point.z*.02);

          return max(gyr, gyr2) + text*.9;
      }

      vec3 GetNormal(vec3 point, float time) {
        float distance = GetDistance(point, time);
        vec2 e = vec2(.01,0);

        vec3 normal = distance - vec3(
            GetDistance(point-e.xyy, time),
            GetDistance(point-e.yxy, time),
            GetDistance(point-e.yyx, time));

        return normalize(normal);
      }

      float RayMarch(vec3 rayOrgin, vec3 rayDirection, float time) {
        float distance=0.;
          for(int i=0; i<140; i++) {
            vec3 point = rayOrgin + rayDirection * distance;
              float surfaceDistance = GetDistance(point, time);
              distance += surfaceDistance;
              // Stop marching if we go too far or we are close enough of surface
              if(distance>20. || surfaceDistance<.001) break;
          }
          return distance;
      }

      float GetLight(vec3 point, vec3 normal, vec3 lightPos, float time) {

        vec3 direction = normalize(lightPos-point);

        float dif = clamp(dot(normal, direction), 0., 1.);

        float d = RayMarch(point+normal*.1, direction, time);
        if ( d < length(lightPos-point)) dif *= .5;

        return dif;
      }

      vec4 doFractalGyroid(vec2 uv, float time) {
          vec3 ro = vec3(0, 1.5, 0);

          vec3 rd = normalize(vec3(uv.x, uv.y, 1));

          float d = RayMarch(ro, rd, time);

          vec3 col = vec3(uColor.rgb + uKickCounter);

          vec3 lightPos = vec3(0, 0, 17);

          if (d < 20.) {
              vec3 p = ro + rd * d;
              vec3 n = GetNormal(p, time);
              float light = GetLight(p, n, lightPos, time);
              // color
              col = vec3(light);
          }
          //col.b += d*.01;
          col *= uColor.rgb * 2.0;
          //col *= 1.2;
          col += 0.075;


          return vec4(col, 1.);
      }

        void main() {
          vec2 r = vec2(uWidth, uHeight);
          vec2 uv = (gl_FragCoord.xy-.5*r.xy)/r.y;

          gl_FragColor = doFractalGyroid(uv, uTime) + uFlicker + uKickCounter;
        }
    </script>

    <link rel="stylesheet" href="demo.css" />
  </head>
  <body>
    <canvas id="webgl-canvas" width="480" height="480"></canvas>
    <canvas id="webgl-canvas-2" width="480" height="480"></canvas>

    <div class="slide">
      <section id="outron" class="hidden">
        <image
          class="logo-animations"
          src="./img/outron.svg"
          style="mix-blend-mode: color-dodge"
        />
      </section>
    </div>

    <div class="slide">
      <section id="title" class="hidden">
        <image class="logo-animations" src="./img/title_3.svg" />
      </section>
    </div>

    <div class="slide" style="mix-blend-mode: color-dodge">
      <section id="text"></section>
    </div>
    <div class="slide" style="mix-blend-mode: color-dodge">
      <section id="text-2"></section>
    </div>
    <div class="slide" style="mix-blend-mode: screen">
      <section id="text-3"></section>
    </div>
    <div class="slide">
      <section id="cyborg" class="hidden">
        <image id="cyborg-svg" src="./img/wakeup.svg" />
      </section>
    </div>
    <section id="vignette">
      <img
        src="img/vignette.png"
        style="width: 100%; height: 100%; mix-blend-mode: multiply"
      />
    </section>
    <section id="info" onclick="play()">CLICK TO START</section>

    <section id="debug">
      <div>now: <span id="debug-time"></span></div>
      <div>fps: <span id="debug-fps"></span></div>
      <div>delta: <span id="debug-delta"></span></div>
      <div><span id="debug-output"></span></div>
      <div id="debug-canvas"></div>
      <div id="debug-light-color-buttons"></div>

      <div>
        <label for="text-input">Text: </label>
        <input id="text-input" type="text" />
        <input id="text-duration-input" type="number" value="10" />
        <input id="text-delay-input" type="number" value="-1" />
        <select id="text-style-input">
          <option value="METAL">METAL</option>
          <option value="SUNSET">SUNSET</option>
          <option value="SOLID_RED">SOLID RED</option>
          <option value="SOLID_WHITE">SOLID WHITE</option>
          <option value="PINK_STROKE">PINK STROKE</option>
          <option value="SOLID_TEAL">SOLID TEAL</option>
          <option value="SUNSET_STROKE">SUNSET STROKE</option>
        </select>
        <select id="text-slide-input">
          <option value="text">LAYER 1</option>
          <option value="text-2">LAYER 2</option>
          <option value="text-3">LAYER 3</option>
        </select>
        <select id="text-animation-input">
          <option value="text-ch-fadein">FADE 1</option>
          <option value="text-ch-fadein-2">FADE 2</option>
        </select>
        <input type="button" onclick="setTextSlideText()" value="Change" />
      </div>
      <div>
        <label for="display-element-id-input">Element ID: </label>
        <select id="display-element-id-input">
          <option value="outron">OUTRON logo</option>
          <option value="webgl-canvas">Canvas</option>
          <option value="webgl-canvas-2">Canvas 2</option>
          <option value="text">Text Layer 1</option>
          <option value="text-2">Text Layer 2</option>
          <option value="text-3">Text Layer 3</option>
          <option value="title">Demo title</option>
          <option value="cyborg">Cyborg</option>
          <option value="vignette">Vignette</option>
        </select>
        <label for="display-element-class-input">new class: </label>
        <select id="display-element-class-input">
          <option value="reset">reset</option>
          <option value="fade-in">fade in</option>
          <option value="fade-out">fade out</option>
          <option value="blur-in">blur in</option>
          <option value="blur-out">blur out</option>
          <option value="blur">blur</option>
          <option value="blur-fast">blur fast</option>
          <option value="hue-rotate">rotate hue</option>
          <option value="saturate">saturate</option>
          <option value="brightness">brightness</option>
          <option value="zoom-in">zoom in</option>
          <option value="zoom-out">zoom out</option>
          <option value="fade-from-white">fade from white</option>
          <option value="fade-to-black">fade to black</option>
          <option value="fade-from-black">fade from black</option>
        </select>
        <input type="button" onclick="changeElementClass()" value="Change" />
      </div>
      <div>
        <fieldset id="debug-scenes">
          <legend>Scenes</legend>
          <input type="button" onclick="changeEffect(3)" value="Tunnel (3)" />
          <input
            type="button"
            onclick="changeEffect(0)"
            value="Tunnel + Metaballs (0)"
          />
          <input
            type="button"
            onclick="changeEffect(7)"
            value="Tunnel + Metacubes (7)"
          />
          <input
            type="button"
            onclick="changeEffect(1)"
            value="Fractal 1 (1)"
          />
          <input
            type="button"
            onclick="changeEffect(10)"
            value="Rosebud (10)"
          />
          <input
            type="button"
            onclick="changeEffect(2)"
            value="Rosebud + Metaballs (2)"
          />
          <input
            type="button"
            onclick="changeEffect(9)"
            value="Rosebud + Metacubes (9)"
          />
          <input
            type="button"
            onclick="changeEffect(4)"
            value="Fractal 2 + Metaballs (4)"
          />
          <input
            type="button"
            onclick="changeEffect(8)"
            value="Fractal 2 + Metacubes (8)"
          />
          <input type="button" onclick="changeEffect(5)" value="Cyborg (5)" />
          <input
            type="button"
            onclick="changeEffect(6)"
            value="Fractal 3 + Metaballs (6)"
          />
        </fieldset>
      </div>
    </section>

    <section id="debug-events">
      <div>
        <label
          ><input
            id="debug-events-show-only-current-events-checkbox"
            type="checkbox"
          />
          show only current events</label
        >
      </div>
      <div id="debug-events-table">
        <table style="width: 100%">
          <tbody id="debug-events-table-body"></tbody>
        </table>
      </div>
    </section>

    <dialog id="edit-event-dialog">
      <form>
        <div>
          <label>ID: </label>
          <input id="edit-event-id" type="text" />
        </div>
        <br />
        <div>
          <label>Time: </label>
          <input id="edit-event-time" type="number" />
        </div>
        <br />
        <div>
          <label>Type: </label>
          <select id="edit-event-type">
            <option value="1">Tunnel Palette / Variation</option>
            <option value="2">Tunnel Texture</option>
            <option value="3">Tunnel Stretch</option>
            <option value="4">Hit</option>
            <option value="5">Kick</option>
            <option value="6">Light Color</option>
            <option value="7">Display (element class)</option>
            <option value="9">Text</option>
            <option value="10">Change Effect</option>
          </select>
        </div>
        <br />
        <label>Parameters:</label>
        <div>
          <textarea
            id="edit-event-json"
            style="width: 500px; height: 150px"
          ></textarea>
        </div>
        <div>
          <button value="cancel" formmethod="dialog">Cancel</button>
          <button
            id="edit-event-save-button"
            value="default"
            formmethod="dialog"
          >
            Save
          </button>
        </div>
      </form>
    </dialog>

    <audio id="music" controls src="./audio/OUTRON_49_02.mp3"></audio>
  </body>
  <script>
    const inputElements = document.getElementsByTagName("input");
    for (let i = 0; i < inputElements.length; i++) {
      console.log(inputElements.item(i).id);
      inputElements.item(i).onkeydown = (event) => {
        event.stopPropagation(true);
      };
    }

    const textareaElements = document.getElementsByTagName("textarea");
    for (let i = 0; i < textareaElements.length; i++) {
      console.log(textareaElements.item(i).id);
      textareaElements.item(i).onkeydown = (event) => {
        event.stopPropagation(true);
      };
    }

    let demoPlaying = false;

    /*
    document.getElementById("slogan").innerHTML = textToSVG({
      text: "WAKE UP",
      charStyle: "",
      fill: TEXT_STYLES.SOLID_RED.fill,
      stroke: TEXT_STYLES.SOLID_RED.stroke,
    });*/

    function play() {
      const url = new URL(document.location);
      const musicEnabled = url.searchParams.get("music")
        ? url.searchParams.get("music") === "true"
        : true;
      const clearEffects = url.searchParams.get("clear-effects") === "true";
      const showDevTools = url.searchParams.get("dev-tools") === "true";
      const showAudio = url.searchParams.get("show-audio") === "true";
      const showTextures = url.searchParams.get("show-textures") === "true";
      const showEvents = url.searchParams.get("show-events") === "true";
      const showCursor = url.searchParams.get("show-cursor") === "true";

      if (showDevTools === true) {
        document.getElementById("debug").style.display = "block";
        renderLightPaletteButtons();
      }

      if (showEvents === true) {
        document.getElementById("debug-events").style.display = "block";
      }

      const audio = document.getElementById("music");

      if (showAudio === true) {
        audio.style.display = "inline-block";
      }

      if (!demoPlaying) {
        if (musicEnabled === true) {
          audio
            .play()
            .then(() => {
              demoPlaying = true;
              document.getElementById("info").style.display = "none";
              if (!showCursor) {
                document.getElementById("vignette").style.cursor = "none";
              }
              //document.getElementById("outron").style.opacity = 0.0;
              main({
                musicEnabled,
                clearEffects,
                showDevTools,
                showTextures,
                showEvents,
              });
            })
            .catch((error) => {
              console.error(error);
            });
        } else {
          demoPlaying = true;
          document.getElementById("info").style.display = "none";
          //document.getElementById("outron").style.opacity = 0.0;
          main({ musicEnabled, clearEffects, showDevTools });
        }
      }
    }

    function renderLightPaletteButtons() {
      const lightPaletteButtonsElement = document.getElementById(
        "debug-light-color-buttons"
      );
      for (let i = 0; i < lightPalette.length; i++) {
        const buttonElement = document.createElement("button");
        buttonElement.type = "button";
        buttonElement.style.backgroundColor = `rgb(${
          lightPalette[i][0] * 255
        },${lightPalette[i][1] * 255},${lightPalette[i][2] * 255})`;

        buttonElement.onclick = (event) => {
          console.log(lightPalette[i]);
          eventToBeAdded = {
            id: `light-color-${
              timeline.getEventsByType(EVENT_TYPES.LIGHT_COLOR).length + 1
            }`,
            type: EVENT_TYPES.LIGHT_COLOR,
            params: { index: i },
          };
        };
        lightPaletteButtonsElement.appendChild(buttonElement);
      }
    }

    function renderEvents(timeline, now) {
      const showOnlyCurrentEvents = document.getElementById(
        "debug-events-show-only-current-events-checkbox"
      ).checked;
      const elementsTableBodyElement = document.getElementById(
        "debug-events-table-body"
      );

      if (now === undefined) {
        now = document.getElementById("music").currentTime * 1000;
      }

      elementsTableBodyElement.innerHTML = "";

      const currentEvents = timeline.getCurrentEvents(now);

      timeline.events.forEach((event, index) => {
        const eventRowElement = document.createElement("tr");
        eventRowElement.id = event.id + "-row";

        if (showOnlyCurrentEvents) {
          if (currentEvents.find((e) => e.id === event.id)) {
            eventRowElement.style.display = null;
          } else {
            eventRowElement.style.display = "none";
          }
        }

        const eventStartCellElement = document.createElement("td");
        eventStartCellElement.textContent = Math.floor(event.start);
        eventStartCellElement.style.cursor = "pointer";
        eventStartCellElement.style.textDecoration = "underline";
        eventStartCellElement.onclick = (e) => {
          document.getElementById("music").currentTime = event.start / 1000;
        };
        eventRowElement.appendChild(eventStartCellElement);

        const eventIdCellElement = document.createElement("td");
        eventIdCellElement.textContent = event.id;
        eventIdCellElement.style.cursor = "pointer";
        eventIdCellElement.style.textDecoration = "underline";
        eventIdCellElement.onclick = (e) => {
          document.getElementById("edit-event-id").value = event.id;
          document.getElementById("edit-event-time").value = event.start;
          document.getElementById("edit-event-type").value = event.type;
          document.getElementById("edit-event-json").value =
            event.params === undefined
              ? ""
              : JSON.stringify(event.params, null, 2);
          document.getElementById("edit-event-save-button").onclick = () => {
            event.params = JSON.parse(
              document.getElementById("edit-event-json").value
            );
          };
          document.getElementById("edit-event-dialog").show();
        };
        eventRowElement.appendChild(eventIdCellElement);

        const eventTypeCellElement = document.createElement("td");
        eventTypeCellElement.textContent = EVENT_TYPES.toString(event.type);
        eventRowElement.appendChild(eventTypeCellElement);

        const eventParamsCellElement = document.createElement("td");
        eventParamsCellElement.style.width = "5px";
        switch (event.type) {
          case EVENT_TYPES.LIGHT_COLOR: {
            const color = lightPalette[event.params.index];
            eventParamsCellElement.style.backgroundColor = `rgb(${
              color[0] * 255
            },${color[1] * 255},${color[2] * 255})`;
            break;
          }
          case EVENT_TYPES.TEXT: {
            const color = lightPalette[event.params.index];
            eventParamsCellElement.textContent = `${event.params.text} (${event.params.slide})`;
            eventParamsCellElement.style.color =
              TEXT_STYLES[event.params.style].fill;
            break;
          }
          case EVENT_TYPES.DISPLAY: {
            eventParamsCellElement.textContent = event.params.id;
            break;
          }
          case EVENT_TYPES.EFFECT: {
            eventParamsCellElement.textContent = EFFECTS[event.params.id].name;
            break;
          }
          case EVENT_TYPES.PALETTE: {
            eventParamsCellElement.textContent = event.params.index;
            break;
          }
          case EVENT_TYPES.TEXTURE: {
            switch (event.params.texture) {
              case TEXTURES.STRIPES:
                eventParamsCellElement.textContent = "Stripes";
                break;
              case TEXTURES.GRID:
                eventParamsCellElement.textContent = "Grid";
                break;
            }

            break;
          }
        }
        eventRowElement.appendChild(eventParamsCellElement);

        const eventRemoveCellElement = document.createElement("td");
        eventRemoveCellElement.className = "remove-event";
        eventRemoveCellElement.textContent = "x";
        eventRemoveCellElement.onclick = (e) => {
          timeline.removeEventById(event.id);
          document.getElementById(event.id + "-row").remove();
        };
        eventRowElement.appendChild(eventRemoveCellElement);

        elementsTableBodyElement.appendChild(eventRowElement);
        /*
        if (event.type === EVENT_TYPES.LIGHT_COLOR) {
          const eventEditRowElement = document.createElement("tr");
          eventEditRowElement.className = 'event-edit-row';
          eventEditRowElement.id = event.id + "-row-edit";
          const editEventCellElement = document.createElement("td");
          lightPalette.forEach(color => {
            const colorButton =
          })


          eventEditRowElement.appendChild(editEventCellElement);
          elementsTableBodyElement.appendChild(eventEditRowElement);
        }*/
      });
    }

    let previousCurrentEventElements = [];

    function updateEvents(timeline, now) {
      const showOnlyCurrentEvents = document.getElementById(
        "debug-events-show-only-current-events-checkbox"
      ).checked;

      const currentEvents = timeline.getCurrentEvents(now);

      /*
      if (
        currentEvents.length === previousCurrentEventElements.length &&
        currentEvents.every((event) =>
          previousCurrentEventElements.includes(event)
        )
      ) {
        return;
      }*/

      previousCurrentEventElements.forEach((element) => {
        element.className = "";
        if (showOnlyCurrentEvents) {
          element.style.display = "none";
        }
      });

      previousCurrentEventElements = [];

      currentEvents.forEach((event) => {
        const currentEventElement = document.getElementById(event.id + "-row");
        currentEventElement.className = "current";
        if (showOnlyCurrentEvents) {
          currentEventElement.style.display = null;
        }
        previousCurrentEventElements.push(currentEventElement);
      });
    }

    function setTextSlideText() {
      //const textElement = document.getElementById("text");
      const text = document.getElementById("text-input").value;
      const duration = parseInt(
        document.getElementById("text-duration-input").value
      );
      const delay = parseInt(document.getElementById("text-delay-input").value);
      const style = document.getElementById("text-style-input").value;
      const slide = document.getElementById("text-slide-input").value;
      const animation = document.getElementById("text-animation-input").value;

      eventToBeAdded = {
        type: EVENT_TYPES.TEXT,
        params: {
          text,
          style,
          slide,
          delay: !isNaN(delay) && delay !== -1 ? delay : undefined,
          duration,
          animation,
        },
      };
    }

    function changeElementClass() {
      const id = document.getElementById("display-element-id-input").value;
      const className = document.getElementById(
        "display-element-class-input"
      ).value;

      eventToBeAdded = {
        type: EVENT_TYPES.DISPLAY,
        params: {
          id,
          className,
        },
      };
    }

    function changeEffect(id) {
      eventToBeAdded = {
        type: EVENT_TYPES.EFFECT,
        params: {
          id,
        },
      };
    }
  </script>
</html>
